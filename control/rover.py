import numpy as np
import matplotlib.pyplot as plt
import scipy
from scipy.interpolate import LSQUnivariateSpline

import sentinel
import sensors
import ir
import sonar
import servo

class Rover():
    """ TODO
    """

    def __init__(self, sen = None, calib_dir = None):
        """ TODO
        """
        if sen is None:
            sen = sentinel.Sentinel()
        elif type(sen) is str:
            sen = sentinel.Sentinel(str)
        elif type(sen) != sentinel.Sentinel:
            raise TypeError("The argument `sen` must be `None`, of type `str` "
                                                       "or of type `Sentinel`")

        self.sen = sen

        if calib_dir == None:
            calib_dir = sensors.DEFAULT_CALIBRATION_DATA_DIR

        self.scan_data = None

        self.ir_conv = sensors.gen_ir_converter(calib_dir + "/ir.csv")
        self.sonar_conv = sensors.gen_sonar_converter(calib_dir + "/sonar.csv")
        self.servo_conv = sensors.gen_servo_converter(calib_dir + "/servo.csv")

        # Startup the figure to be used for displaying scan data:
        fig = plt.figure()
        self.scan_viewer = plt.subplot(111, polar=True)

        self.scan_viewer.grid(True)




    def full_scan(self, plot_scan = True):
        """ Communicates with the rover to scan the area in front of it,
        generating distance data. Then uses this data to regress the results.

        All data generated by the method will be *appended* to the `scan_data`
        field and a regression of the results will be saved

        A plot of the scan's results will be displayed if and only if
        `plot_scan` is `True`.
        """

        (ir_data, sonar_data) = self.scan(5, start = 0, end = 180)
        scan_data = np.concatenate((ir_data, sonar_data), axis = 0)

        if plot_scan == True:
            self._plot_scan_data(scan_data)

        return scan




    def scan(self, n, start = 0, end = 180):
        """ This communicates with the rover to generate distance data while
        making a single pass from angle `start` to angle `end`.

        The argument `n` indicates the number of distance readings to be
        recorded from both the IR sensor and the sonar sensor at each angle (up
        to and including the angle `end`).

        The results are returned as a pair of `np.ndarray` objects. The first
        is the IR data, while the second is the sonar data. Both of these
        arrays have two columns: the first column is the angle while the second
        column is the distance measurement.

        So, a method call will, in total, prompt

            2 * n * (abs(end - start) + 1)

        distance readings to be recorded and returned.

        Note that the scan can happen in either direction (i.e. clockwise or
        counter-clockwise) depending on which angle is bigger than the other.
        """

        if start <= end:
            angles = np.arange(start, end+1)
        else:
            angles = np.arange(start, end-1, -1)

        # The number of rows in each of the results arrays:
        num_rows = n * len(angles)

        ir_data = np.empty(shape = (num_rows, 2))
        sonar_data = np.empty(shape = (num_rows, 2))

        for (idx, angle) in enumerate(angles):

            servo.pulse(self.sen, self.servo_conv(angle))
            rows = [r for r in range(idx * n, (idx+1) * n)]

            ir_data[rows, 0] = angle
            ir_data[rows, 1] = ir.readings(self.sen, n)

            sonar_data[rows, 0] = angle
            sonar_data[rows, 1] = sonar.readings(self.sen, n)

        # Perform the conversion from raw readings to distances.
        ir_data[:, 1] = self.ir_conv(ir_data[:, 1])
        sonar_data[:, 1] = self.sonar_conv(sonar_data[:, 1])

        return (ir_data, sonar_data)




    def save_scan_data(self, csv_file):
        """ Saves the current contents of the `scan_data` field to the `.csv`
        file indicated by the given `str`.

        Note that any previous contents of that file will be clobbered.
        """

        raise NotImplementedError




    def _plot_scan_regression(self, regression):
        """ Plots the given `regression` object onto the `scan_viewer` using
        polar coordinates.
        """

        plt.cla()
        self.scan_viewer.set_rmax(100)
        thetas = np.linspace(0, 180, 361)
        rs = regression(thetas)
        self.scan_viewer.plot(theta, r, color='r', linewidth=2)
        plt.draw()





    def _plot_scan_data(self, data):
        """ Plots a two-column `np.ndarray` of data generated by a scan on
        the `scan_viewer`, using polar coordinates. 
        
        The first column of `data` is expected to be angles (in degrees), while
        the second column is meant to be the corresponding radial distance (in
        centimeters).
        """

        plt.cla()
        self.scan_viewer.set_rmax(100)
        self.scan_viewer.scatter(data[:, 0] * (np.pi / 180.0), data[:, 1])
        plt.draw()



    def _regress_scan_data(data):
        """ Looks at the current contents of `scan_data` and uses it to
        generate an approximate distance to the nearest object at every angle
        for which there is scan data. """

        knots = np.linspace(0, 180, 61)
        return LSQUnivariateSpline(data[:, 0], data[:, 1])
